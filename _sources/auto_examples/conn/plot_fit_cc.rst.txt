.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_conn_plot_fit_cc.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_conn_plot_fit_cc.py:


Information transfer about a continuous variable
================================================

This example illustrates how to compute the amount of information that is sent
from one region to another about a specific continuous feature. For further
details, see Bim et al. 2019 :cite:`bim2019non`


.. code-block:: default

    import numpy as np

    from frites.simulations import sim_distant_cc_ms
    from frites.dataset import DatasetEphy
    from frites.workflow import WfFit

    import matplotlib.pyplot as plt
    plt.style.use('seaborn-white')








Simulate electrophysiological data
----------------------------------

Let's start by simulating data coming from multiple subjects using the
function :func:`frites.simulations.sim_distant_cc_ms`. As a result, the `x`
output is a list of length `n_subjects` of arrays, each one with a shape of
n_epochs, n_sites, n_times


.. code-block:: default


    n_subjects = 5
    n_epochs = 200
    x, y, roi, times = sim_distant_cc_ms(n_subjects, n_epochs=n_epochs)







Define the electrophysiological dataset
---------------------------------------

Now we define an instance of :class:`frites.dataset.DatasetEphy`


.. code-block:: default


    ds = DatasetEphy(x, y, roi=roi, times=times)







Compute the bidirectionnal information transfer
-----------------------------------------------

Once we have the dataset instance, we can then define an instance of workflow
:class:`frites.workflow.WfFit`. This instance is used to compute the
information transfer


.. code-block:: default


    wf = WfFit()
    mi, _ = wf.fit(ds, n_perm=10)
    print(mi)

    # when `net=False` it means that the information transfer is directed which
    # means we can either look at the amount of informations sent from roi_0 to
    # roi_1 or roi_1 to roi_0.
    it_0_to_1 = mi.sel(source='roi_0', target='roi_1')
    it_1_to_0 = mi.sel(source='roi_1', target='roi_0')

    plt.plot(it_0_to_1, label='roi_0 -> roi_1')
    plt.plot(it_1_to_0, label='roi_1 -> roi_0')
    plt.title('Bidirectionnal FIT')
    plt.xlabel('Time'), plt.ylabel('MI (bits)')
    plt.show()




.. image:: /auto_examples/conn/images/sphx_glr_plot_fit_cc_001.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray (source: 2, target: 2, times: 370)>
    array([[[0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.0272271 , 0.00979323, 0.01669858, ..., 0.00581013,
             0.03733889, 0.02670395]],

           [[0.0106087 , 0.00995216, 0.00567009, ..., 0.02466835,
             0.01168617, 0.015961  ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ]]])
    Coordinates:
      * source   (source) <U5 'roi_0' 'roi_1'
      * target   (target) <U5 'roi_0' 'roi_1'
      * times    (times) float32 -0.69924814 -0.68922305 ... 2.989975 3.0
    Attributes:
        max_delay:      0.3
        net:            False
        mi_type:        cc
        inference:      rfx
        mi_method:      gc
        kernel:         none
        th:             1.3818427
        tfce:           none
        mcp:            cluster
        tail:           1
        cluster_th:     none
        cluster_alpha:  0.05
        ttested:        True



Compute the unidirectionnal information transfer
------------------------------------------------

Note that you can also compute the unidirectionnal FIT which is define as the
difference between `FIT(source - >target) - FIT(target -> source)`.


.. code-block:: default


    wf = WfFit()
    mi, _ = wf.fit(ds, net=True, n_perm=10)
    print(mi)
    it_net = mi.sel(source='roi_0', target='roi_1')

    plt.plot(it_net, label='roi_0 <-> roi_1')
    plt.title('Unidirectionnal FIT')
    plt.xlabel('Time'), plt.ylabel('MI (bits)')
    plt.legend()
    plt.show()


.. image:: /auto_examples/conn/images/sphx_glr_plot_fit_cc_002.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray (source: 2, target: 2, times: 370)>
    array([[[ 0.        ,  0.        ,  0.        , ...,  0.        ,
              0.        ,  0.        ],
            [ 0.01661841, -0.00015893,  0.01102849, ..., -0.01885822,
              0.02565273,  0.01074295]],

           [[ 0.        ,  0.        ,  0.        , ...,  0.        ,
              0.        ,  0.        ],
            [ 0.        ,  0.        ,  0.        , ...,  0.        ,
              0.        ,  0.        ]]])
    Coordinates:
      * source   (source) <U5 'roi_0' 'roi_1'
      * target   (target) <U5 'roi_0' 'roi_1'
      * times    (times) float32 -0.69924814 -0.68922305 ... 2.989975 3.0
    Attributes:
        max_delay:      0.3
        net:            True
        mi_type:        cc
        inference:      rfx
        mi_method:      gc
        kernel:         none
        th:             2.3889697
        tfce:           none
        mcp:            cluster
        tail:           0
        cluster_th:     none
        cluster_alpha:  0.05
        ttested:        True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.353 seconds)


.. _sphx_glr_download_auto_examples_conn_plot_fit_cc.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_fit_cc.py <plot_fit_cc.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_fit_cc.ipynb <plot_fit_cc.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
