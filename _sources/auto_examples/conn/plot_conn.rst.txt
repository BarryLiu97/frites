.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_conn_plot_conn.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_conn_plot_conn.py:


Estimate instantaneous connectivity using MI
============================================

This example illustrates how to estimate the instantaneous comodulations using
mutual information between pairwise ROI and also perform statistics.


.. code-block:: default

    import numpy as np
    from itertools import product

    from frites.simulations import sim_multi_suj_ephy
    from frites.dataset import DatasetEphy
    from frites.workflow import WfComod

    import matplotlib.pyplot as plt
    plt.style.use('seaborn-white')








Simulate electrophysiological data
----------------------------------

Let's start by simulating MEG / EEG electrophysiological data coming from
multiple subjects using the function
:func:`frites.simulations.sim_multi_suj_ephy`. As a result, the `x` output
is a list of length `n_subjects` of arrays, each one with a shape of
n_epochs, n_sites, n_times


.. code-block:: default


    modality = 'meeg'
    n_subjects = 5
    n_epochs = 50
    n_times = 100
    x, roi, _ = sim_multi_suj_ephy(n_subjects=n_subjects, n_epochs=n_epochs,
                                   n_times=n_times, modality=modality,
                                   random_state=0, n_roi=4)
    times = np.linspace(-1, 1, n_times)







Simulate spatial correlations
-----------------------------

Bellow, we start by simulating some distant correlations by injecting the
activity of an ROI to another


.. code-block:: default

    for k in range(n_subjects):
        x[k][:, [1], slice(20, 40)] += x[k][:, [0], slice(20, 40)]
        x[k][:, [2], slice(60, 80)] += x[k][:, [3], slice(60, 80)]
    print(f'Corr 1 : {roi[0][0]}-{roi[0][1]} between [{times[20]}-{times[40]}]')
    print(f'Corr 2 : {roi[0][2]}-{roi[0][3]} between [{times[60]}-{times[80]}]')





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Corr 1 : L_VCcm-L_VCl between [-0.5959595959595959--0.19191919191919182]
    Corr 2 : L_VCs-L_Cu between [0.21212121212121215-0.6161616161616164]



Define the electrophysiological dataset
---------------------------------------

Now we define an instance of :class:`frites.dataset.DatasetEphy`


.. code-block:: default


    dt = DatasetEphy(x, roi=roi, times=times)







Compute the pairwise connectivity
---------------------------------

Once we have the dataset instance, we can then define an instance of workflow
:class:`frites.workflow.WfComod`. This instance is then used to compute the
pairwise connectivity


.. code-block:: default


    n_perm = 100  # number of permutations to compute
    kernel = np.hanning(10)  # used for smoothing the MI

    wf = WfComod(kernel=kernel)
    mi, pv = wf.fit(dt, n_perm=n_perm, n_jobs=1)
    print(mi)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray 'mi' (source: 4, target: 4, times: 100)>
    array([[[0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.01842208, 0.02406251, 0.02750422, ..., 0.06213146,
             0.05655586, 0.04440434],
            [0.02770122, 0.03899341, 0.04850729, ..., 0.09280769,
             0.0990997 , 0.08878132],
            [0.07227535, 0.09675911, 0.11006359, ..., 0.06616406,
             0.04571074, 0.02689257]],

           [[0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.01995809, 0.02980501, 0.03847941, ..., 0.04031742,
             0.03693827, 0.03065904],
            [0.04409665, 0.06801132, 0.08811049, ..., 0.10888197,
             0.09368213, 0.0707151 ]],

           [[0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.06497172, 0.09283924, 0.10946753, ..., 0.07669559,
             0.06127905, 0.04158382]],

           [[0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ],
            [0.        , 0.        , 0.        , ..., 0.        ,
             0.        , 0.        ]]])
    Coordinates:
      * source   (source) <U6 'L_VCcm' 'L_VCl' 'L_VCs' 'L_Cu'
      * target   (target) <U6 'L_VCcm' 'L_VCl' 'L_VCs' 'L_Cu'
      * times    (times) float32 -1.0 -0.9798 -0.9596 -0.9394 ... 0.9596 0.9798 1.0
    Attributes:
        mi_type:         cc
        inference:       rfx
        mi_method:       gc
        kernel:          [0.         0.11697778 0.41317591 0.75       0.96984631 ...
        n_perm:          100
        random_state:    none
        n_bins:          none
        ttest_pop_mean:  0.06710494649076602
        ttest_sigma:     0.001
        th:              1.281707268054139
        tfce:            none
        mcp:             cluster
        tail:            1
        cluster_th:      none
        cluster_alpha:   0.05
        ttested:         0
        type:            mi



Plot the result of the DataArray
--------------------------------


.. code-block:: default


    # set to NaN everywhere it's not significant
    is_signi = pv.data < .05
    pv.data[~is_signi] = np.nan
    pv.data[is_signi] = 1.02 * mi.data.max()

    # plot each pair separately
    plt.figure(figsize=(9, 7))
    for s, t in product(mi.source.data, mi.target.data):
        if s == t: continue
        # select the mi and p-values for the (source, target)
        mi_st = mi.sel(source=s, target=t)
        pv_st = pv.sel(source=s, target=t)
        color = np.random.rand(3,)
        plt.plot(times, mi_st, label=f"{s}-{t}", color=color)
        plt.plot(times, pv_st, color=color, lw=4)
        if not np.isnan(pv_st.data).all():
            x_txt = times[~np.isnan(pv_st)].mean()
            y_txt = 1.03 * mi.data.max()
            plt.text(x_txt, y_txt, f"{s}-{t}", color=color, ha='center')
    plt.legend()
    plt.xlabel('Times')
    plt.ylabel('Mi (bits)')
    plt.title('Pairwise connectivity')
    plt.show()



.. image:: /auto_examples/conn/images/sphx_glr_plot_conn_001.png
    :class: sphx-glr-single-img





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.738 seconds)


.. _sphx_glr_download_auto_examples_conn_plot_conn.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_conn.py <plot_conn.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_conn.ipynb <plot_conn.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
