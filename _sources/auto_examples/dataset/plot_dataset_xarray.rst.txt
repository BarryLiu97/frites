.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_dataset_plot_dataset_xarray.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_dataset_plot_dataset_xarray.py:


Define an electrophysiological dataset using Xarray
===================================================

This example illustrates how to define a dataset using Xarray. If you don't
know this library, we can simplify by saying that it provides containers that
accept arrays but you can also labelize your dimensions. Another way of seeing
it, pandas is mostly made for tables (i.e 2D arrays) while Xarray provide
almost the same functionalities but for multi-dimensional arrays.



.. code-block:: default

    import numpy as np
    import pandas as pd

    from xarray import DataArray
    from frites.dataset import DatasetEphy

    import matplotlib.pyplot as plt







Create artificial data
----------------------

We start by creating some random data for several subjects. To do that, each
subject is going have a 3 dimensional array of shape
(n_epochs, n_channels, n_times). Then, all of the arrays are grouped together
in a list of length (n_subjects,)


.. code-block:: default


    n_subjects = 5
    n_epochs = 10
    n_channels = 5
    n_times = 100
    sf = 512

    x, ch = [], []
    for k in range(n_subjects):
        # generate single subject data
        x_suj = np.random.rand(n_epochs, n_channels, n_times)
        # generate some random channel names
        ch_suj = np.array([f"ch_{r}" for r in range(n_channels)])
        # concatenate in a list
        x.append(x_suj)
        ch.append(ch_suj)
    # finally lets create a time vector
    times = np.arange(n_times) / sf
    epochs = np.arange(n_epochs)







Xarray conversion to DataArray
------------------------------

Here, we convert the NumPy arrays to xarray.DataArray


.. code-block:: default


    x_xr = []
    for k in range(n_subjects):
        # DataArray conversion
        arr_xr = DataArray(x[k], dims=('epochs', 'channels', 'times'),
                           coords=(epochs, ch[k], times))
        # finally, replace it in the original list
        x_xr.append(arr_xr)
    print(x_xr[0])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray (epochs: 10, channels: 5, times: 100)>
    array([[[0.86902157, 0.26798566, 0.77430928, ..., 0.13574919,
             0.73445302, 0.41553407],
            [0.52182661, 0.16158656, 0.30182404, ..., 0.01462104,
             0.43888641, 0.33165185],
            [0.74866819, 0.35580415, 0.56525522, ..., 0.3514169 ,
             0.44441022, 0.97847323],
            [0.63500331, 0.40537625, 0.19784552, ..., 0.65132174,
             0.37687389, 0.07070188],
            [0.03861636, 0.62240283, 0.85192755, ..., 0.87877526,
             0.830311  , 0.74467136]],

           [[0.24936335, 0.27795174, 0.35259118, ..., 0.20150636,
             0.77884025, 0.04674147],
            [0.00830709, 0.8230495 , 0.72694103, ..., 0.44250027,
             0.94230641, 0.98856867],
            [0.51786997, 0.14753277, 0.80184807, ..., 0.04401833,
             0.21359957, 0.47011755],
            [0.22018813, 0.01730493, 0.12608961, ..., 0.05394241,
             0.91082636, 0.07369336],
            [0.7915594 , 0.17550352, 0.28404788, ..., 0.137651  ,
    ...
             0.69626181, 0.49932433],
            [0.39184017, 0.51552285, 0.73195663, ..., 0.80979385,
             0.36990271, 0.88332861],
            [0.23472855, 0.6277745 , 0.4075741 , ..., 0.85677164,
             0.2681309 , 0.54912662],
            [0.64027877, 0.09087007, 0.95695312, ..., 0.13583764,
             0.14205255, 0.83127354],
            [0.03555687, 0.61131931, 0.12081404, ..., 0.99266802,
             0.5527545 , 0.37772826]],

           [[0.89147033, 0.36379153, 0.21556472, ..., 0.3858699 ,
             0.1882105 , 0.42390693],
            [0.90828003, 0.61551437, 0.09363089, ..., 0.62253103,
             0.54108437, 0.02483422],
            [0.0654672 , 0.82263758, 0.40466405, ..., 0.44689679,
             0.23632565, 0.38301333],
            [0.94970758, 0.34017996, 0.68349755, ..., 0.81167905,
             0.89100527, 0.69539146],
            [0.39157969, 0.48789329, 0.72344082, ..., 0.29571825,
             0.19763105, 0.63027021]]])
    Coordinates:
      * epochs    (epochs) int64 0 1 2 3 4 5 6 7 8 9
      * channels  (channels) <U4 'ch_0' 'ch_1' 'ch_2' 'ch_3' 'ch_4'
      * times     (times) float64 0.0 0.001953 0.003906 ... 0.1895 0.1914 0.1934



Build the dataset
-----------------

Finally, we pass the data to the :class:`frites.dataset.DatasetEphy` class
in order to create the dataset


.. code-block:: default


    # here, we specify to the DatasetEphy class that the roi dimension is actually
    # called 'channels' in the DataArray and the times dimension is called 'times'
    dt = DatasetEphy(x_xr, roi='channels', times='times')
    print(dt)

    print('Time vector : ', dt.times)
    print('ROI\n: ', dt.df_rs)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.Dataset>
    Dimensions:    (roi: 5, times: 100, trials: 10)
    Coordinates:
      * trials     (trials) int64 0 1 2 3 4 5 6 7 8 9
      * roi        (roi) <U4 'ch_0' 'ch_1' 'ch_2' 'ch_3' 'ch_4'
        agg_ch     (roi) int64 0 0 0 0 0
      * times      (times) float64 0.0 0.001953 0.003906 ... 0.1895 0.1914 0.1934
        subject    (trials) int64 0 0 0 0 0 0 0 0 0 0
    Data variables:
        subject_0  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_1  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_2  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_3  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_4  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
    Attributes:
        __version__:   0.3.8
        modality:      electrophysiology
        dtype:         DatasetEphy
        y_dtype:       none
        z_dtype:       none
        mi_type:       none
        mi_repr:       none
        sfreq:         512.0
        agg_ch:        True
        multivariate:  False
        nb_min_suj:    False
        n_subjects:    5
    Time vector :  [0.         0.00195312 0.00390625 0.00585938 0.0078125  0.00976562
     0.01171875 0.01367188 0.015625   0.01757812 0.01953125 0.02148438
     0.0234375  0.02539062 0.02734375 0.02929688 0.03125    0.03320312
     0.03515625 0.03710938 0.0390625  0.04101562 0.04296875 0.04492188
     0.046875   0.04882812 0.05078125 0.05273438 0.0546875  0.05664062
     0.05859375 0.06054688 0.0625     0.06445312 0.06640625 0.06835938
     0.0703125  0.07226562 0.07421875 0.07617188 0.078125   0.08007812
     0.08203125 0.08398438 0.0859375  0.08789062 0.08984375 0.09179688
     0.09375    0.09570312 0.09765625 0.09960938 0.1015625  0.10351562
     0.10546875 0.10742188 0.109375   0.11132812 0.11328125 0.11523438
     0.1171875  0.11914062 0.12109375 0.12304688 0.125      0.12695312
     0.12890625 0.13085938 0.1328125  0.13476562 0.13671875 0.13867188
     0.140625   0.14257812 0.14453125 0.14648438 0.1484375  0.15039062
     0.15234375 0.15429688 0.15625    0.15820312 0.16015625 0.16210938
     0.1640625  0.16601562 0.16796875 0.16992188 0.171875   0.17382812
     0.17578125 0.17773438 0.1796875  0.18164062 0.18359375 0.18554688
     0.1875     0.18945312 0.19140625 0.19335938]
    ROI
    :        #subjects  ...  keep
    roi              ...      
    ch_0          5  ...  True
    ch_1          5  ...  True
    ch_2          5  ...  True
    ch_3          5  ...  True
    ch_4          5  ...  True

    [5 rows x 3 columns]



MultiIndex support
------------------

DataArray also supports multi-indexing of a single dimension.


.. code-block:: default


    # create a continuous regressor (prediction error, delta P etc.)
    dp = np.random.uniform(-1, 1, (n_epochs,))
    # create a discret variable (e.g experimental conditions)
    cond = np.array([0] * 5 + [1] * 5)

    # now, create a multi-index using pandas
    midx = pd.MultiIndex.from_arrays((dp, cond), names=('dp', 'blocks'))

    # convert again the original arrays but this time, the epoch dimension is going
    # to be a multi-index
    x_xr = []
    for k in range(n_subjects):
        # DataArray conversion
        arr_xr = DataArray(x[k], dims=('epochs', 'channels', 'times'),
                           coords=(midx, ch[k], times))
        # finally, replace it in the original list
        x_xr.append(arr_xr)
    print(x_xr[0])

    # finally, when you create your dataset you can also specify the y and z inputs
    # by providing their names in the DataArray
    dt = DatasetEphy(x_xr, roi='channels', times='times', y='dp', z='blocks')
    print(dt)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray (epochs: 10, channels: 5, times: 100)>
    array([[[0.86902157, 0.26798566, 0.77430928, ..., 0.13574919,
             0.73445302, 0.41553407],
            [0.52182661, 0.16158656, 0.30182404, ..., 0.01462104,
             0.43888641, 0.33165185],
            [0.74866819, 0.35580415, 0.56525522, ..., 0.3514169 ,
             0.44441022, 0.97847323],
            [0.63500331, 0.40537625, 0.19784552, ..., 0.65132174,
             0.37687389, 0.07070188],
            [0.03861636, 0.62240283, 0.85192755, ..., 0.87877526,
             0.830311  , 0.74467136]],

           [[0.24936335, 0.27795174, 0.35259118, ..., 0.20150636,
             0.77884025, 0.04674147],
            [0.00830709, 0.8230495 , 0.72694103, ..., 0.44250027,
             0.94230641, 0.98856867],
            [0.51786997, 0.14753277, 0.80184807, ..., 0.04401833,
             0.21359957, 0.47011755],
            [0.22018813, 0.01730493, 0.12608961, ..., 0.05394241,
             0.91082636, 0.07369336],
            [0.7915594 , 0.17550352, 0.28404788, ..., 0.137651  ,
    ...
             0.69626181, 0.49932433],
            [0.39184017, 0.51552285, 0.73195663, ..., 0.80979385,
             0.36990271, 0.88332861],
            [0.23472855, 0.6277745 , 0.4075741 , ..., 0.85677164,
             0.2681309 , 0.54912662],
            [0.64027877, 0.09087007, 0.95695312, ..., 0.13583764,
             0.14205255, 0.83127354],
            [0.03555687, 0.61131931, 0.12081404, ..., 0.99266802,
             0.5527545 , 0.37772826]],

           [[0.89147033, 0.36379153, 0.21556472, ..., 0.3858699 ,
             0.1882105 , 0.42390693],
            [0.90828003, 0.61551437, 0.09363089, ..., 0.62253103,
             0.54108437, 0.02483422],
            [0.0654672 , 0.82263758, 0.40466405, ..., 0.44689679,
             0.23632565, 0.38301333],
            [0.94970758, 0.34017996, 0.68349755, ..., 0.81167905,
             0.89100527, 0.69539146],
            [0.39157969, 0.48789329, 0.72344082, ..., 0.29571825,
             0.19763105, 0.63027021]]])
    Coordinates:
      * epochs    (epochs) MultiIndex
      - dp        (epochs) float64 -0.2855 0.3435 0.3114 ... -0.4629 -0.2701 0.3371
      - blocks    (epochs) int64 0 0 0 0 0 1 1 1 1 1
      * channels  (channels) <U4 'ch_0' 'ch_1' 'ch_2' 'ch_3' 'ch_4'
      * times     (times) float64 0.0 0.001953 0.003906 ... 0.1895 0.1914 0.1934
    <xarray.Dataset>
    Dimensions:    (roi: 5, times: 100, trials: 10)
    Coordinates:
      * trials     (trials) int64 0 1 2 3 4 5 6 7 8 9
        y          (trials) float64 -0.2855 0.3435 0.3114 ... -0.4629 -0.2701 0.3371
        z          (trials) int64 0 0 0 0 0 1 1 1 1 1
      * roi        (roi) <U4 'ch_0' 'ch_1' 'ch_2' 'ch_3' 'ch_4'
        agg_ch     (roi) int64 0 0 0 0 0
      * times      (times) float64 0.0 0.001953 0.003906 ... 0.1895 0.1914 0.1934
        subject    (trials) int64 0 0 0 0 0 0 0 0 0 0
    Data variables:
        subject_0  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_1  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_2  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_3  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
        subject_4  (trials, roi, times) float64 nan nan nan nan ... nan nan nan nan
    Attributes:
        __version__:   0.3.8
        modality:      electrophysiology
        dtype:         DatasetEphy
        y_dtype:       float
        z_dtype:       int
        mi_type:       ccd
        mi_repr:       I(x; y (continuous)) | z (discret)
        sfreq:         512.0
        agg_ch:        True
        multivariate:  False
        nb_min_suj:    False
        n_subjects:    5




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.177 seconds)


.. _sphx_glr_download_auto_examples_dataset_plot_dataset_xarray.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_dataset_xarray.py <plot_dataset_xarray.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_dataset_xarray.ipynb <plot_dataset_xarray.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
