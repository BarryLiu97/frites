.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_xarray_plot_xr_quick_tour.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_xarray_plot_xr_quick_tour.py:


Xarray : Quick tour
===================

Basically, this example gives a very small introduction to Xarray (very small).
We illustrate how to define a DataArray container, access its components,
perform some of the basic operations and slicing / indexing.


.. code-block:: default

    import numpy as np
    import xarray as xr
    import pandas as pd







Simulate data
-------------

lets start by creating a random spatio-temporal array


.. code-block:: default


    n_times = 30
    n_roi = 7
    times_vec = np.linspace(-1, 1, n_times)
    roi_vec = np.array([f"roi_{k}" for k in range(n_roi)])
    np_data = np.random.rand(n_times, n_roi)
    print(np_data.shape)
    print('*' * 79)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    (30, 7)
    *******************************************************************************



Xarray conversion and access to the internal components
-------------------------------------------------------

A DataArray is a container (like a well known numpy array) except that you
can add a label to each coordinate. To this end, the input `dims` is a tuple
that describes the dimension names and `coords` describes the value along
this coordinate


.. code-block:: default


    # let's convert it to a DataArray
    da_data = xr.DataArray(np_data, dims=('times', 'roi'),
                           coords=(times_vec, roi_vec))
    print(da_data.shape)
    print(da_data)
    print('*' * 79)

    # if you want to get the dimension names and values
    print(f'Dimension names : {da_data.dims}')
    print(f'Dimension values : {da_data.coords}')
    print(f"Data of a specific dimension : {da_data.roi.data}")
    print('*' * 79)

    # if you want to get the original NumPy array enter the following :
    da_data.data

    # if you want to change the values of a coordinate
    da_data['roi'] = np.array([f"roi_{k % 3}" for k in range(n_roi)])
    print(f"New ROI names : {da_data.roi.data}")
    print('*' * 79)

    # if you need to compute or get the min / max / mean across a specific
    # dimension
    da_data.min('times')  # minimum across time points
    da_data.max('times')  # maximum across time points
    da_data.mean('roi')   # mean across all ROI

    # similarly to Pandas, it's also possible to group along a dimension and then
    # take the mean. For example, here's how to group and mean by roi names
    da_m = da_data.groupby('roi').mean('roi')
    print(da_m)
    print('*' * 79)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    (30, 7)
    <xarray.DataArray (times: 30, roi: 7)>
    array([[0.94396404, 0.960343  , 0.88614036, 0.9363087 , 0.2019    ,
            0.48633713, 0.74602823],
           [0.38147843, 0.41004543, 0.95269229, 0.6907436 , 0.27651097,
            0.77567369, 0.34168921],
           [0.54280191, 0.71447174, 0.53094704, 0.13196013, 0.48145562,
            0.68997342, 0.37910691],
           [0.42268742, 0.03784332, 0.58800814, 0.49762041, 0.54282206,
            0.69126125, 0.04544786],
           [0.69331389, 0.89650573, 0.71405399, 0.76893751, 0.19087974,
            0.60693623, 0.50009127],
           [0.68670057, 0.72867904, 0.46391178, 0.49141625, 0.1879936 ,
            0.41576488, 0.14561163],
           [0.88674154, 0.38950168, 0.90845142, 0.3301513 , 0.58536054,
            0.88803543, 0.13198605],
           [0.78493111, 0.30740124, 0.07872534, 0.24883012, 0.99386594,
            0.11337122, 0.29088367],
           [0.04158696, 0.10444754, 0.91985495, 0.13098552, 0.14484052,
            0.59420171, 0.29878923],
           [0.68654436, 0.95475332, 0.35582728, 0.04850818, 0.20425337,
            0.58024658, 0.92788063],
    ...
           [0.75769999, 0.44670491, 0.00877052, 0.76346271, 0.31790876,
            0.49554099, 0.54856879],
           [0.22190941, 0.1000556 , 0.30028656, 0.7513557 , 0.97226585,
            0.79815091, 0.85399368],
           [0.31217071, 0.28643906, 0.8200884 , 0.07324385, 0.21850902,
            0.48620026, 0.17222197],
           [0.59306743, 0.30302969, 0.25122183, 0.96223527, 0.41982178,
            0.84185893, 0.24353414],
           [0.81683555, 0.20541144, 0.75438656, 0.19786235, 0.09103481,
            0.27959366, 0.38142182],
           [0.11854608, 0.40119781, 0.65070533, 0.49650182, 0.81090285,
            0.35301906, 0.18818314],
           [0.9695104 , 0.05706918, 0.32055772, 0.10042658, 0.82589472,
            0.59399996, 0.30053816],
           [0.95752618, 0.98252331, 0.05812183, 0.28826717, 0.06067081,
            0.29822202, 0.37534813],
           [0.69574532, 0.73813424, 0.99531328, 0.37897282, 0.03708883,
            0.49446279, 0.39822267],
           [0.79612977, 0.05730847, 0.54342669, 0.81605727, 0.71672497,
            0.44642141, 0.43488526]])
    Coordinates:
      * times    (times) float64 -1.0 -0.931 -0.8621 -0.7931 ... 0.8621 0.931 1.0
      * roi      (roi) <U5 'roi_0' 'roi_1' 'roi_2' 'roi_3' 'roi_4' 'roi_5' 'roi_6'
    *******************************************************************************
    Dimension names : ('times', 'roi')
    Dimension values : Coordinates:
      * times    (times) float64 -1.0 -0.931 -0.8621 -0.7931 ... 0.8621 0.931 1.0
      * roi      (roi) <U5 'roi_0' 'roi_1' 'roi_2' 'roi_3' 'roi_4' 'roi_5' 'roi_6'
    Data of a specific dimension : ['roi_0' 'roi_1' 'roi_2' 'roi_3' 'roi_4' 'roi_5' 'roi_6']
    *******************************************************************************
    New ROI names : ['roi_0' 'roi_1' 'roi_2' 'roi_0' 'roi_1' 'roi_2' 'roi_0']
    *******************************************************************************
    <xarray.DataArray (times: 30, roi: 3)>
    array([[0.87543365, 0.5811215 , 0.68623874],
           [0.47130374, 0.3432782 , 0.86418299],
           [0.35128965, 0.59796368, 0.61046023],
           [0.32191857, 0.29033269, 0.63963469],
           [0.65411422, 0.54369273, 0.66049511],
           [0.44124281, 0.45833632, 0.43983833],
           [0.4496263 , 0.48743111, 0.89824343],
           [0.4415483 , 0.65063359, 0.09604828],
           [0.15712057, 0.12464403, 0.75702833],
           [0.55431105, 0.57950335, 0.46803693],
           [0.47474377, 0.48094886, 0.76335649],
           [0.46231853, 0.55973599, 0.03404181],
           [0.67151566, 0.33343984, 0.12169829],
           [0.65515607, 0.23969596, 0.4048954 ],
           [0.41173328, 0.34939914, 0.43088642],
           [0.49806649, 0.32713733, 0.97123443],
           [0.79050867, 0.56675007, 0.51771954],
           [0.40225985, 0.78633307, 0.73906915],
           [0.53760906, 0.36743162, 0.8146667 ],
           [0.56133779, 0.57725726, 0.45363489],
           [0.68991049, 0.38230683, 0.25215575],
           [0.60908626, 0.53616073, 0.54921873],
           [0.18587884, 0.25247404, 0.65314433],
           [0.59961228, 0.36142573, 0.54654038],
           [0.46537324, 0.14822312, 0.51699011],
           [0.26774368, 0.60605033, 0.5018622 ],
           [0.45682505, 0.44148195, 0.45727884],
           [0.54038049, 0.52159706, 0.17817193],
           [0.49098027, 0.38761153, 0.74488804],
           [0.68235743, 0.38701672, 0.49492405]])
    Coordinates:
      * times    (times) float64 -1.0 -0.931 -0.8621 -0.7931 ... 0.8621 0.931 1.0
      * roi      (roi) object 'roi_0' 'roi_1' 'roi_2'
    *******************************************************************************



Xarray slicing and indexing
---------------------------

Now we show how to slice the container


.. code-block:: default


    # select a single specific ROI based on it's name
    da_data.sel(roi='roi_0')

    # select a time range
    da_time_slice = da_data.sel(times=slice(-.5, .5))
    print(f"Temporal selection : {da_time_slice.coords}")
    print('*' * 79)

    # off course, spatio-temporal selection is also supported
    da_st = da_data.sel(times=slice(-.5, .5), roi='roi_1')
    print(f"Spatio-temporal selection : {da_st.coords}")
    print('*' * 79)

    # you can also slice according to indices
    da_isel = da_data.isel(times=slice(10, 20))
    print(f"Integer selection : {da_isel.coords}")
    print('*' * 79)

    # however, if you want for example select multiple items based on their names,
    # you have to use booleans. Here's a small example that's using Pandas
    roi = da_data.roi.data
    use_roi = ['roi_0', 'roi_2']
    is_roi = pd.Series(roi).str.contains('|'.join(use_roi))
    da_mi = da_data.isel(roi=is_roi)
    print(f"Multi-items selection : {da_mi.coords}")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Temporal selection : Coordinates:
      * times    (times) float64 -0.4483 -0.3793 -0.3103 ... 0.3103 0.3793 0.4483
      * roi      (roi) <U5 'roi_0' 'roi_1' 'roi_2' 'roi_0' 'roi_1' 'roi_2' 'roi_0'
    *******************************************************************************
    Spatio-temporal selection : Coordinates:
      * times    (times) float64 -0.4483 -0.3793 -0.3103 ... 0.3103 0.3793 0.4483
      * roi      (roi) <U5 'roi_1' 'roi_1'
    *******************************************************************************
    Integer selection : Coordinates:
      * times    (times) float64 -0.3103 -0.2414 -0.1724 ... 0.1724 0.2414 0.3103
      * roi      (roi) <U5 'roi_0' 'roi_1' 'roi_2' 'roi_0' 'roi_1' 'roi_2' 'roi_0'
    *******************************************************************************
    Multi-items selection : Coordinates:
      * times    (times) float64 -1.0 -0.931 -0.8621 -0.7931 ... 0.8621 0.931 1.0
      * roi      (roi) <U5 'roi_0' 'roi_2' 'roi_0' 'roi_2' 'roi_0'



Xarray attributes
-----------------

One of the nice features of DataArray is that it supporting setting
attributes. Therefore you can add, for example, the parameters that describe
your analysis


.. code-block:: default


    # adding a few string attributes
    da_data.attrs['inference'] = 'ffx'
    da_data.attrs['stats'] = 'cluster-based'
    da_data.attrs['description'] = """Here's a small description of the analysis
    I'm currently running. Trying to find a difference between condition 1. vs 2.
    """

    # you can also add vectors (but not arrays) to the attributes
    da_data.attrs['vector'] = np.arange(30)

    # however, "None" seems to pose a problem when saving the results. Therefore,
    # one quick way to solve this is simply to convert it into a string
    da_data.attrs['none_problem'] = str(None)

    print(da_data)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <xarray.DataArray (times: 30, roi: 7)>
    array([[0.94396404, 0.960343  , 0.88614036, 0.9363087 , 0.2019    ,
            0.48633713, 0.74602823],
           [0.38147843, 0.41004543, 0.95269229, 0.6907436 , 0.27651097,
            0.77567369, 0.34168921],
           [0.54280191, 0.71447174, 0.53094704, 0.13196013, 0.48145562,
            0.68997342, 0.37910691],
           [0.42268742, 0.03784332, 0.58800814, 0.49762041, 0.54282206,
            0.69126125, 0.04544786],
           [0.69331389, 0.89650573, 0.71405399, 0.76893751, 0.19087974,
            0.60693623, 0.50009127],
           [0.68670057, 0.72867904, 0.46391178, 0.49141625, 0.1879936 ,
            0.41576488, 0.14561163],
           [0.88674154, 0.38950168, 0.90845142, 0.3301513 , 0.58536054,
            0.88803543, 0.13198605],
           [0.78493111, 0.30740124, 0.07872534, 0.24883012, 0.99386594,
            0.11337122, 0.29088367],
           [0.04158696, 0.10444754, 0.91985495, 0.13098552, 0.14484052,
            0.59420171, 0.29878923],
           [0.68654436, 0.95475332, 0.35582728, 0.04850818, 0.20425337,
            0.58024658, 0.92788063],
    ...
           [0.75769999, 0.44670491, 0.00877052, 0.76346271, 0.31790876,
            0.49554099, 0.54856879],
           [0.22190941, 0.1000556 , 0.30028656, 0.7513557 , 0.97226585,
            0.79815091, 0.85399368],
           [0.31217071, 0.28643906, 0.8200884 , 0.07324385, 0.21850902,
            0.48620026, 0.17222197],
           [0.59306743, 0.30302969, 0.25122183, 0.96223527, 0.41982178,
            0.84185893, 0.24353414],
           [0.81683555, 0.20541144, 0.75438656, 0.19786235, 0.09103481,
            0.27959366, 0.38142182],
           [0.11854608, 0.40119781, 0.65070533, 0.49650182, 0.81090285,
            0.35301906, 0.18818314],
           [0.9695104 , 0.05706918, 0.32055772, 0.10042658, 0.82589472,
            0.59399996, 0.30053816],
           [0.95752618, 0.98252331, 0.05812183, 0.28826717, 0.06067081,
            0.29822202, 0.37534813],
           [0.69574532, 0.73813424, 0.99531328, 0.37897282, 0.03708883,
            0.49446279, 0.39822267],
           [0.79612977, 0.05730847, 0.54342669, 0.81605727, 0.71672497,
            0.44642141, 0.43488526]])
    Coordinates:
      * times    (times) float64 -1.0 -0.931 -0.8621 -0.7931 ... 0.8621 0.931 1.0
      * roi      (roi) <U5 'roi_0' 'roi_1' 'roi_2' 'roi_0' 'roi_1' 'roi_2' 'roi_0'
    Attributes:
        inference:     ffx
        stats:         cluster-based
        description:   Here's a small description of the analysis\nI'm currently ...
        vector:        [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 ...
        none_problem:  None



Xarray to an other format
-------------------------

Finally, we quickly illustrate how to convert a DataArray into, for example,
a pandas.DataFrame


.. code-block:: default


    print(da_data.to_pandas())



.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    roi           roi_0  ...     roi_0
    times                ...          
    -1.000000  0.943964  ...  0.746028
    -0.931034  0.381478  ...  0.341689
    -0.862069  0.542802  ...  0.379107
    -0.793103  0.422687  ...  0.045448
    -0.724138  0.693314  ...  0.500091
    -0.655172  0.686701  ...  0.145612
    -0.586207  0.886742  ...  0.131986
    -0.517241  0.784931  ...  0.290884
    -0.448276  0.041587  ...  0.298789
    -0.379310  0.686544  ...  0.927881
    -0.310345  0.452283  ...  0.625867
    -0.241379  0.001284  ...  0.754394
    -0.172414  0.318177  ...  0.896224
    -0.103448  0.394533  ...  0.595810
    -0.034483  0.992637  ...  0.194607
     0.034483  0.316887  ...  0.347384
     0.103448  0.976274  ...  0.676507
     0.172414  0.433227  ...  0.379774
     0.241379  0.274903  ...  0.896831
     0.310345  0.766464  ...  0.901566
     0.379310  0.757700  ...  0.548569
     0.448276  0.221909  ...  0.853994
     0.517241  0.312171  ...  0.172222
     0.586207  0.593067  ...  0.243534
     0.655172  0.816836  ...  0.381422
     0.724138  0.118546  ...  0.188183
     0.793103  0.969510  ...  0.300538
     0.862069  0.957526  ...  0.375348
     0.931034  0.695745  ...  0.398223
     1.000000  0.796130  ...  0.434885

    [30 rows x 7 columns]




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.124 seconds)


.. _sphx_glr_download_auto_examples_xarray_plot_xr_quick_tour.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_xr_quick_tour.py <plot_xr_quick_tour.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_xr_quick_tour.ipynb <plot_xr_quick_tour.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
